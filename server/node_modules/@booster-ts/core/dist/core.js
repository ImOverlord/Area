"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:no-var-requires
require("reflect-metadata");
/**
 * booster
 * @description Decorator to retreive Classes
 * @param data info to attach to the Class
 */
exports.booster = function (data) {
    return function (target) {
        Reflect.defineMetadata("data", data || {}, target);
        return;
    };
};
/**
 * Injector
 * @description Container to Store and Retreive Classes
 */
var Injector = /** @class */ (function () {
    function Injector() {
        this.container = [];
    }
    /**
     * register
     * @description Register a Class with a custom name
     * @param className Name you want the class to have
     * @param target Class to register
     * @example
     *  ```
     *  @booster()
     *  class Example {
     *  }
     *
     *  Inject.register('CustomExample', Example);
     *  ```
     */
    Injector.prototype.register = function (className, target) {
        var _this = this;
        var found = false;
        var tokens = Reflect.getMetadata("design:paramtypes", target) || [];
        var inject = tokens.map(function (token) { return _this.resolve(token); });
        var newClass = {
            class: new (target.bind.apply(target, __spreadArrays([void 0], inject)))(),
            name: className,
            data: Reflect.getMetadata('data', target),
            target: target
        };
        this.container.map(function (container) {
            if (container.name === className) {
                found = true;
                return newClass;
            }
            return container;
        });
        if (!found)
            this.container.push(newClass);
        return newClass.class;
    };
    /**
     * inject
     * @description Retrive class with dependencies injected
     * @param target Class to inject
     * @example
     * ```
     *  @booster()
     *  class Greeter {
     *     public hello() {
     *          return "Hello";
     *     }
     *  }
     *
     *  @booster()
     *  class Human {
     *     constructor(
     *          greet: Greeter
     *     ) { }
     *
     *     public hello(): string {
     *          return greet.hello();
     *     }
     *  }
     *
     *  const example = Inject.inject(Example);
     *  example.hello() // Returns "Hello"
     *  ```
     */
    Injector.prototype.inject = function (target) {
        return this.resolve(target);
    };
    /**
     * getByKey
     * @description Gets all class with a specific key attached as metadata
     * @param keyName Key to find on Target
     */
    Injector.prototype.getByKey = function (keyName) {
        var _this = this;
        var classArray = [];
        this.container.forEach(function (container) {
            var data = Reflect.getMetadata('data', container.target);
            if (data === undefined)
                return;
            if (data[keyName] !== undefined)
                classArray.push(_this.resolve(container.target));
        });
        return classArray;
    };
    /**
     * getByValue
     * @description Gets all class with a specific value to the key attached as metadata
     * @param keyName Key to find on Target
     * @param value to find on key
     */
    Injector.prototype.getByValue = function (keyName, value) {
        var _this = this;
        var classArray = [];
        this.container.forEach(function (container) {
            var data = Reflect.getMetadata('data', container.target);
            if (data === undefined)
                return;
            if (data[keyName] === value)
                classArray.push(_this.resolve(container.target));
        });
        return classArray;
    };
    /**
     * getContainerByKey
     * @description Returns Container with certain key
     * @param keyName to find on target
     */
    Injector.prototype.getContainerByKey = function (keyName) {
        var _this = this;
        var containerArray = [];
        this.container.forEach(function (container) {
            var data = Reflect.getMetadata('data', container.target);
            if (data === undefined)
                return;
            if (data[keyName] !== undefined) {
                _this.resolve(container.target);
                containerArray.push(container);
            }
        });
        return containerArray;
    };
    /**
     * getContainerByValue
     * @description Gets all class with a specific value to the key attached as metadata
     * @param keyName Key to find on Target
     * @param value to find on key
     */
    Injector.prototype.getContainerByValue = function (keyName, value) {
        var _this = this;
        var containerArray = [];
        this.container.forEach(function (container) {
            var data = Reflect.getMetadata('data', container.target);
            if (data === undefined)
                return;
            if (data[keyName] === value) {
                _this.resolve(container.target);
                containerArray.push(container);
            }
        });
        return containerArray;
    };
    /**
     * resolve
     * @description Resolves dependencies and retruns injected Class
     * @param target Class
     */
    Injector.prototype.resolve = function (target) {
        var _this = this;
        var tokens = Reflect.getMetadata("design:paramtypes", target) || [];
        var inject = tokens.map(function (token) { return _this.resolve(token); });
        var className = target.name;
        var temp = this.container.filter(function (dependency) {
            if (dependency.name === className)
                return dependency;
            return null;
        });
        if (temp.length > 0)
            return temp[0].class;
        var newClass = {
            class: new (target.bind.apply(target, __spreadArrays([void 0], inject)))(),
            name: className,
            data: Reflect.getMetadata('data', target),
            target: target
        };
        this.container.push(newClass);
        return newClass.class;
    };
    return Injector;
}());
exports.Injector = Injector;
//# sourceMappingURL=core.js.map